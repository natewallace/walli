/*
 * This class is used to perform NTLM authentication and is based on documentation found on the following site:
 * http://davenport.sourceforge.net/ntlm.html as well as code from the open source Chromium project which can be found here:
 * https://code.google.com/p/chromium/codesearch#chromium/src/net/http/http_auth_handler_ntlm_portable.cc&q=ntlmssp&sq=package:chromium&l=137
 *
 * The NTLM authentication process goes as follows:
 * 1.) send type 1 message to the server.
 * 2.) recieve type 2 message from the server in response to type 1 message.
 * 3.) send type 3 message to the server in response to type 2 message.
 */
public class NTLMAuth {

    /*
     * The flags that are supported.
     * (NegotiateUnicode, NegotiateOEM, RequestTarget, NegotiateNTLMKey, NegotiateAlwaysSign, NegotiateNTLM2Key)
     */
    private static final integer NEGOTIATE_FLAGS = 557575;
    
    /*
     * The size of the header in type 3 messages.
     */
    private static final integer MESSAGE_TYPE_3_HEADER_SIZE = 64;   

    /*
     * Get type 1 message to send to the server.
     *
     * @return A type 1 message that can be sent to the server to begin authentication.
     */
    public string getType1Message() {
        integer[] result = new integer[] {
            78,  84,  76,  77,  83,  83,  80,   0,                      // 0:  NTLMSSP
             1,   0,   0,  0 };                                         // 8:  Type marker             
        result.addAll(BitConverter.getBytesForUInt32(NEGOTIATE_FLAGS));     // 12: Flags 
        WriteSecurityBuffer(result, null, null);                        // 16: Domain security buffer (empty)
        WriteSecurityBuffer(result, null, null);                        // 24: Workstation security buffer (empty)
        
        return BitConverter.encodeBase64String(result);
    }
    
    /*
     * Get type 3 message to send to the server.
     *
     * @param type2Message The response from the server after sending the type 1 message generated by a call to getType1Message.
     * @param user The domain and username used for authentication which should formatted like the example: UP\DUX07
     * @param password The password used for authentication.
     */
    public string getType3Message(string type2Message, string user, string password) {
    
        // separate domain and user
        integer slashIndex = user.indexOfAny('/\\');
        if (slashIndex == -1)
            throw new RuntimeException('user parameter doesn\'t include a domain value.');
        string userDomain = user.subString(0, slashIndex);
        string userName = user.subString(slashIndex + 1, user.length());
        
        //
        // parse and validate type 2 message
        //
        integer[] type2Bytes = BitConverter.decodeBase64String(type2Message);   
        
        if (type2Bytes.size() < 32)
            throw new RuntimeException('type2Message is less than minimum 32 bytes required');
        if (type2Bytes [0] != 78 ||
            type2Bytes [1] != 84 ||
            type2Bytes [2] != 76 ||
            type2Bytes [3] != 77 ||
            type2Bytes [4] != 83 ||
            type2Bytes [5] != 83 ||
            type2Bytes [6] != 80 ||
            type2Bytes [7] != 0)
            throw new RuntimeException('type2Message doesn\'t have a valid NTLMSSP header');
        if (type2Bytes[8] != 2)
            throw new RuntimeException('type2Message isn\'t a type 2 message');
            
        integer flags = BitConverter.toUInt32(type2Bytes, 20);  
        
        boolean isUnicode = (flags & 1) == 1;
            
        integer[] challenge = new integer[8];
        for (integer i = 24; i < 32; i++)
            challenge[i - 24] = type2Bytes[i];            

        //
        // generate responses
        //
        integer[] lmResponse = null;
        integer[] ntlmResponse = null;
        
        MD4Hash md4 = new MD4Hash();
        integer[] ntlmHash = md4.digest(BitConverter.EncodeUTF16String(password));
            
        if ((flags & 524288) > 0) { // NegotiateNTLM2Key
            
            long maxLong = (long)Math.pow(2, 64);
            long random = Math.roundToLong(Math.random() * maxLong);
            integer[] nonce = BitConverter.getBytesForUInt64(random);
            
            lmResponse = new integer[0];
            lmResponse.addAll(nonce);
            for (integer i = 0; i < 16; i++)
                lmResponse.add(0);
                            
            integer[] key = new integer[0];
            key.addAll(challenge);
            key.addAll(nonce);
            blob digest = Crypto.generateDigest('MD5', BitConverter.getBlob(key));
            
            ntlmResponse = createNTLMResponse(ntlmHash, BitConverter.getBytes(digest));           
        }
        else { // NegotiateNTLMKey
        
            lmResponse = new integer[24];
            for (integer i = 0; i < 24; i++)
                lmResponse[i] = 0;
                
            ntlmResponse = createNTLMResponse(ntlmHash, challenge);
        }
        
        //
        // populate the message
        //
        integer[] header = new integer[] { 78, 84, 76, 77, 83, 83, 80, 0,       // 0: NTLMSSP
                                           3,   0,  0,  0 };                // 8: Type marker
        integer[] body = new integer[0];
        
        // 12: LM response
        WriteSecurityBuffer(header, body, lmResponse);
        
        // 20: NTLM response
        WriteSecurityBuffer(header, body, ntlmResponse);
        
        // 28: Domain name
        WriteSecurityBuffer(header, body, isUnicode ? BitConverter.encodeUTF16String(userDomain) : BitConverter.encodeUTF8String(userDomain));
            
        // 36: User name
        WriteSecurityBuffer(header, body, isUnicode ? BitConverter.encodeUTF16String(userName) : BitConverter.encodeUTF8String(userName));        
            
        // 44: Workstation (host)
        WriteSecurityBuffer(header, body, isUnicode ? BitConverter.encodeUTF16String('SalesForce') : BitConverter.encodeUTF8String('SalesForce'));        
        
        // 52: Session key (not used)
        WriteSecurityBuffer(header, body, null);
        
        // 60: Negotiated flags
        header.addAll(BitConverter.getBytesForUInt32(NEGOTIATE_FLAGS & flags));
        
        integer[] message = new integer[0];
        message.addAll(header);
        message.addAll(body);                                  
    
        return BitConverter.encodeBase64String(message);
    }
    
    /*
     * Writes the content out to the body and marks the location in the header.
     * 
     * @param header The header data that the security buffer pointer will be appended to.
     * @param body The body data that the content will be appended to.
     * @param content The data that will be written out to the body.  The position will be recorded in the header. 
                      If this value is null an empty security buffer pointer will be written to the header and the body 
                    won't be modified.
     */
    private void WriteSecurityBuffer(integer[] header, integer[] body, integer[] content) {
        if (content == null || content.size() == 0) {
            header.addAll(BitConverter.getBytesForUInt16(0));
            header.addAll(BitConverter.getBytesForUInt16(0));
            header.addAll(BitConverter.getBytesForUInt32(0));            
        }
        else {
            integer pos = MESSAGE_TYPE_3_HEADER_SIZE + body.size();
            body.addAll(content);
            header.addAll(BitConverter.getBytesForUInt16(content.size()));
            header.addAll(BitConverter.getBytesForUInt16(content.size()));
            header.addAll(BitConverter.getBytesForUInt32(pos));
        }
    }
    
    /*
     * Create NTLM response.
     *
     * @param hash The hash to create an NTLM response with.
     * @param challenge The challenge from the server to create an NTLM response with.
     * @return The NTLM response created from the hash and challenge inputs.
     */
    private integer[] createNTLMResponse(integer[] hash, integer[] challenge) {
        integer[] ntlmHash = new integer[0];
        ntlmHash.addAll(hash);
        for (integer i = 0; i < 5; i++)
            ntlmHash.add(0);                                
        
        integer[] lowKey = createDESKey(ntlmHash , 0);
        integer[] midKey = createDESKey(ntlmHash , 7);
        integer[] highKey = createDESKey(ntlmHash , 14);
        
        DESCrypt des = new DESCrypt();
        integer[] lowResponse = des.encrypt(lowKey, challenge);
        integer[] midResponse = des.encrypt(midKey, challenge);
        integer[] highResponse = des.encrypt(highKey, challenge);
        
        integer[] result = new integer[24];
        for (integer i = 0; i < 8; i++) {
            result[i]      = lowResponse[i];
            result[i + 8]  = midResponse[i];
            result[i + 16] = highResponse[i];
        }        
        return result;    
    }
    
    /*
     * Creates a DES encryption key from the given key material.
     *
     * @param bytes The bytes to create a key with.
     * @param offset The offset to start reading data from in the bytes parameter.
     * @return A DES encryption key.
     */
    public integer[] createDESKey(integer[] bytes, integer offset) {
        integer[] keyBytes = new integer[7];
        for (integer i = offset; i < offset + 7; i++)
            keyBytes[i - offset] = bytes[i];
            
        integer[] material = new integer[8];        
        material[0] = keyBytes[0];
        material[1] = (((keyBytes[0] << 7) & 255) | (keyBytes[1] & 255) >>> 1);
        material[2] = (((keyBytes[1] << 6) & 255) | (keyBytes[2] & 255) >>> 2);
        material[3] = (((keyBytes[2] << 5) & 255) | (keyBytes[3] & 255) >>> 3);
        material[4] = (((keyBytes[3] << 4) & 255) | (keyBytes[4] & 255) >>> 4);
        material[5] = (((keyBytes[4] << 3) & 255) | (keyBytes[5] & 255) >>> 5);
        material[6] = (((keyBytes[5] << 2) & 255) | (keyBytes[6] & 255) >>> 6);
        material[7] = (((keyBytes[6] << 1) & 255)); 
        
        applyOddParity(material);
        
        return material;     
    }
    
    /*
     * Applies odd parity to the given bytes.
     *
     * @param bytes The bytes that odd parity will be applied to.
     */
    private void applyOddParity(integer[] bytes) {
        for (integer i = 0; i < bytes.size(); i++) {
            integer b = bytes[i];
            boolean needsParity = (((((((((b >>> 7) ^ (b >>> 6)) ^ (b >>> 5)) ^ (b >>> 4)) ^ (b >>> 3)) ^ (b >>> 2)) ^ (b >>> 1))) & 1) == 0;
                                    
            if (needsParity)
                bytes[i] |= 1;  
            else
                bytes[i] &= 254;                                  
        }
    }
}